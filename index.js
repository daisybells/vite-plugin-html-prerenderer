import { JSDOM } from "jsdom";
import path from "node:path";

/**
 * Render function that generates an HTML string based on a given input.
 * @callback renderer
 * @param {Object} jsonObjects - JSON arrays imported from .JSON files specified by
 * options.moduleGroups[].jsonPaths
 * @returns {HTML} - Generated output HTML string.
 */

/**
 * Vite plugin that prerenders HTML generated by JS functions to the DOM during
 * build time and run time.
 *
 *
 *
 *
 * @param {Object} options - Settings to configure prerenderer plugin.
 * @param {Object[]} options.moduleGroups - Input modules for each render function
 * and their specific configurations.
 *
 *
 * @param {renderer} options.moduleGroups[].renderFunction - Callback function that
 * generates the replacement HTML to be added to the DOM.
 * @param {string} options.moduleGroups[].selector - The targeted querySelector to be
 * replaced by the newly generated HTML.
 * @param {string|string[]} options.moduleGroups[].dataModules - Vite module imports to be
 * used as the inputs to the generator functions.
 * @param {string|string[]} [options.moduleGroups[].pathIsolate] - File path or array of
 * file paths to isolate render function to. Root directory matches that of the root
 * directory in vite.config.js.
 * @param {string|string[]} [options.moduleGroups[].pathIgnore] - File path or array of
 * file paths to isolate render function to. Root directory matches that of the root
 * directory in vite.config.js.
 * @param {Boolean} [options.moduleGroups[].outer = false] - Boolean value that determines
 * whether to replace the outerHTML or the innerHTML of the DOM node.
 *
 *
 * @returns {import("vite").Plugin} - Vite plugin object.
 */
function viteVanillaPrerenderer(options = {}) {
    const moduleGroups = options?.moduleGroups || [];
    let command;
    let viteServer;
    let resolveId;
    let loadModule;
    const watchedJsonFiles = new Set();

    return {
        name: "vite-vanilla-prerenderer",
        enforce: "post",
        configResolved(config) {
            ({ command } = config);
        },
        configureServer(server) {
            viteServer = server;

            server.watcher.on("change", (file) => {
                const normalizedFile = path.normalize(file);

                if (!watchedJsonFiles.has(normalizedFile)) return;

                console.log(
                    `\n[vite-vanilla-prerenderer] Watched JSON file changed: ${path.relative(
                        process.cwd(),
                        normalizedFile
                    )}. Restarting server...`
                );
                try {
                    server.restart();
                } catch (error) {
                    console.error(
                        `[vite-vanilla-prerenderer] Error restarting server: ${error.message}`
                    );
                }
            });
        },
        buildStart() {
            [resolveId, loadModule] = [this.resolve, this.load];
        },
        async transformIndexHtml(html, context) {
            if (moduleGroups.length === 0) return html;

            const loadModuleData = loadModuleDataCurry(
                command,
                viteServer,
                {
                    resolve: resolveId,
                    load: loadModule,
                },
                watchedJsonFiles
            );

            const prerenderModule = prerenderModuleCurry(context.path);

            const dom = new JSDOM(html);
            const { document } = dom.window;

            const previousDocument = globalThis.document;
            globalThis.document = document;

            try {
                for (const moduleGroup of moduleGroups) {
                    const { dataModules } = moduleGroup;
                    if (!dataModules) {
                        prerenderModule(moduleGroup);
                        continue;
                    }
                    const dataModulePathArray = Array.isArray(dataModules)
                        ? dataModules
                        : [dataModules];

                    const dataModulePromises =
                        dataModulePathArray.map(loadModuleData);

                    // eslint-disable-next-line no-await-in-loop
                    const dataEntries = await Promise.all(dataModulePromises);

                    const loadedData = Object.fromEntries(
                        dataEntries.filter((entry) => entry[1] !== null)
                    );

                    prerenderModule(moduleGroup, loadedData);
                }
            } finally {
                globalThis.document = previousDocument;
            }

            return dom.serialize();
        },
    };
}

function loadModuleDataCurry(
    command,
    viteServer,
    pluginContext,
    watchedJsonFiles
) {
    return async (moduleId) => {
        const key = path.basename(moduleId).split(".")[0];
        const isVirtual = moduleId.startsWith("\0");
        const isFilePath = moduleId.includes(path.sep);
        const isJsonModule =
            moduleId.endsWith(".json") && !isVirtual && isFilePath;

        if (command === "serve" && isJsonModule) {
            const resolvedPath = path.resolve(process.cwd(), moduleId);
            watchedJsonFiles.add(path.normalize(resolvedPath));
        }

        try {
            if (command === "serve") {
                const module = await viteServer.ssrLoadModule(moduleId);

                const data = module.default || module;
                return [key, data];
            }

            const resolvedModule = await pluginContext.resolve(moduleId);

            if (!resolvedModule) return [key, null];

            const loadedModule = await pluginContext.load({
                id: resolvedModule.id,
            });

            const module = await import(
                `data:text/javascript,${encodeURIComponent(loadedModule.code)}`
            );

            const data = module.default || module;
            return [key, data];
        } catch (error) {
            console.error(
                `[vite-vanilla-prerenderer] ⚠️ Failed to load module ${moduleId}:`,
                error.message
            );
        }

        return [key, null];
    };
}

function prerenderModuleCurry(contextPath) {
    return (module, jsonObjects = {}) => {
        const { renderFunction, selector, ...options } = module;
        const { outer, pathIgnore, pathIsolate } = options;

        if (typeof renderFunction !== "function" || !selector) return;

        const isolatePaths = Array.isArray(pathIsolate)
            ? pathIsolate.filter(Boolean)
            : [pathIsolate].filter(Boolean);
        const ignorePaths = Array.isArray(pathIgnore)
            ? pathIgnore.filter(Boolean)
            : [pathIgnore].filter(Boolean);

        const isPathToIsolate = pathMatches(contextPath, isolatePaths);
        const isPathToIgnore = pathMatches(contextPath, ignorePaths);

        if (pathIgnore && isPathToIgnore) return;
        if (pathIsolate && !isPathToIsolate) return;

        const elements = document.querySelectorAll(selector);

        if (elements.length === 0) return;

        for (const element of elements) {
            const result = renderFunction(jsonObjects);
            if (outer) element.outerHTML = result;
            else element.innerHTML = result;
        }
    };
}

/**
 * Check if two file paths are equal to each other.
 *
 * @param {string} contextPath - Current working directory path.
 * @param {string[]} pathsArray - Array of paths to compare to the context path.
 * @returns {Boolean} - Path does or does not match.
 */
function pathMatches(contextPath, pathsArray) {
    return contextPath && pathsArray
        ? pathsArray.some(
              (filePath) =>
                  path.normalize(contextPath.toLowerCase()) ===
                  path.normalize(filePath.toLowerCase())
          )
        : false;
}

export default viteVanillaPrerenderer;
